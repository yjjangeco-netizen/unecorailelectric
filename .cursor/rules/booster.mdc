ALWAYS — 절대 흔들리지 않는 기본 규칙

출력 우선 원칙

불필요한 해설 금지. 작동하는 코드/결과부터 내고, 설명은 EXPLANATION: 제목 하에 간결하게.

불확실한 정보는 배제. 명확한 전제만 사용.

아키텍처·코딩 표준

모든 신규 코드: TypeScript(또는 대상 언어의 정적분석)에서 에러 0, 경고 0 기준으로 제출.

함수는 단일 책임. 60줄 이상 함수 금지, 200줄 이상 파일 분리.

의존성 추가 금지(필요 시 사유·대안 비교 포함한 제안만). 기존 스택·패턴 우선.

하드코딩 금지: 매직넘버/문자열은 상수로 추출.

로깅/예외: 경로별 최소 한 번은 오류 전파 또는 로깅.

DB/데이터 I/O

Cursor 기반 샘플·프로토타이핑은 DB로 SQLite 또는 MS Access만 사용. 원격 DB 연결 금지.

DB 커서 변수에 csr_ 접두사 사용 금지(가독성 중심, 자연스런 이름 사용).

테스트·품질 게이트

신규/변경 로직은 단위테스트 필수(성공·에러 경로, 경계값 포함).

테스트는 결정적·빠름. 네트워크/파일 I/O는 목/가짜로 대체.

커버리지는 핵심 경로 100% 목표(불가 시 사유 명시).

정적 분석, 린트, 포맷터(예: ESLint/Prettier/Ruff 등) 경고까지 0.

보안·성능 최소 기준

입력 검증/인코딩: 모든 외부 입력은 스키마 검증(zod 등) 또는 철저한 타입 가드.

비밀정보: 코드·로그·문서에 비밀 키/토큰 절대 금지.

성능 예산: 핫패스는 Big-O/메모리 기준을 명시하고, 필요 시 미세 최적화.

리소스 해제: 파일/커넥션/리스너는 finally/using 패턴으로 정리.

UI/UX 공통 규칙(웹 UI를 다룰 때)

디자인 토큰(색/타이포/스페이싱)은 하단 Design System을 따른다.

접근성: 텍스트 대비 AA 4.5:1 이상, 큰 텍스트 3:1 이상. 포커스 인디케이터 가시성 확보.

상태 설계: 로딩/빈 상태/에러/성공 UI 모두 제공.

반응형: 최소 3단 브레이크포인트(sm/md/lg)에서 타이포·레이아웃 균형 유지.

출력 형식·패치

가능한 한 최소 변경 DIFF 또는 완전한 파일로 제시.

스키마/타입 선언은 상단에, 테스트/스토리/예시 코드는 하단에 배치.

MANUAL — 필요할 때 켜는 작업 모드

Manual: refactor-core

리팩터링 전용. 기능 변경 금지.

냄새 제거(긴 함수/중복/깊은 중첩/프리미티브 집착), 이름 개선, 순수함수화.

퍼블릭 API 유지, 내부 가시성 축소.

전/후 성능/복잡도 간단 비교 포함.

Manual: write-tests

대상 모듈의 경계·에러·동시성까지 아우르는 테스트 추가.

테이블 기반 케이스와 프로퍼티 기반(가능 시) 혼용.

I/O는 목/스텁. 랜덤은 시드 고정.

Manual: docs

README/사용예/아키텍처 다이어그램 생성·갱신.

변경된 퍼블릭 API의 샘플 코드와 마이그레이션 가이드 포함.

Manual: a11y-audit

키보드 순회, 포커스 트랩, ARIA 속성 점검.

대비/명도, 폼 레이블, 에러 메시지 연결성 검토.

발견 사항은 체크리스트 + 수리 DIFF로 제출.

Manual: perf-bench

핫패스(정렬/검색/파싱/렌더) 미니 벤치 추가.

알고리즘·할당·렌더 수(React) 지표화, 개선 전후를 표로 제시.

Manual: security-review

입력 검증, 직렬화, 경로 조작, 인젝션, 비밀 관리, 권한 경계 검토.

취약지점 리스트와 수정 패치 동시 제공.

Manual: design-polish

컴포넌트의 간격/정렬/타이포/아이콘/애니메이션을 시스템에 맞춰 정제.

상태(hover/focus/disabled/invalid) 전부 정의.

다크모드 대비, 축약/ellipsis 처리, 스켈레톤/에러 UI 개선.

Manual: commit-polish

변경 범위 요약 → 이유 → 영향 → 롤백 계획 순으로 Conventional Commits 형식 작성.

브레이킹 체인지 시 ! 표기 및 마이그 가이드 동봉.

Manual: pr-template

PR 설명에 문제정의 → 해결전략 → 대안비교 → 테스트·리스크 → 스크린샷/벤치 자동 삽입.

DESIGN SYSTEM — 실전형 토큰 & 패턴(웹 UI)

색상(의미 기반)

:root{
  --bg: #0B0E14; /* 다크 기본 */
  --bg-elev: #121723;
  --fg: #E6EAF2;
  --muted: #A7B0C0;
  --primary: #4DA3FF; /* 주요 액션 */
  --success: #5BD897;
  --warn: #FFC857;
  --danger: #FF6B6B;
  --border: #2A3140;
  --focus: #7AA2FF; /* 포커스 링 */
}

대비 목표: 본문 텍스트 ≥ 4.5:1, 큰 텍스트 ≥ 3:1. 상태 변화(hover/focus)에서도 기준 유지.

타이포 스케일(예시)

Display 32 / 700, 1.25 line-height

H1 24 / 700, 1.3

H2 20 / 600, 1.35

Body 16 / 500, 1.5

Caption 13 / 500, 1.45

스페이싱(8px 그리드 + 보정)

4, 8, 12, 16, 20, 24, 32, 40, 48

카드/모달: 24 내·외부 기본, 컴포넌트 간 16.

컴포넌트 규칙

버튼: 터치 타겟 ≥ 40×40px, 키보드 포커스 링 2px, 아이콘 간격 8px.

폼: 라벨은 상단, 도움말/에러 텍스트 연결(ARIA).

리스트/테이블: 헤더 고정, 빈 상태/로딩 스켈레톤, 페이지네이션은 50/100 단위 옵션.

모션(절제)

진입/퇴장 120–200ms, 표준 커브(입력 빠름/출력 느림).

의미 없는 패럴랙스/장식 금지. 시각적 계층을 위한 미세 이동/페이드만.

템플릿(복붙용)

테스트 템플릿(테이블 기반)

// arrange
type Case = { name: string; input: unknown; want: unknown };
const cases: Case[] = [
  { name: "empty", input: "", want: 0 },
  { name: "ascii", input: "abc", want: 3 },
  { name: "unicode", input: "가나다", want: 3 },
];
// act+assert
for (const tc of cases){
  const got = fn(tc.input);
  expect(got).toEqual(tc.want);
}

커밋 메시지(Conventional Commits)

feat(core): add schema-validated parser

- validate input via zod
- split side effects
- add property-based tests

BREAKING CHANGE: parse() now throws ZodError on invalid input

PR 템플릿

## Problem
-

## Solution
-

## Alternatives Considered
-

## Tests & Risks
-

## Screenshots / Benchmarks
-

체크리스트(에이전트 작업 전·후)



프롬프트 예시(한 줄 명령)

리팩터링: "Manual: refactor-core. src/parser.ts 냄새 제거, 함수 분리, DI 도입. 공개 API/동작 동일. DIFF 출력."

테스트 작성: "Manual: write-tests. src/date.ts 경계/에러 포함 테이블 테스트 생성. 랜덤 시드 고정."

접근성 점검: "Manual: a11y-audit. components/* 포커스/레이블/대비 검토 후 수정 DIFF."

디자인 폴리시: "Manual: design-polish. 카드/폼 간격·타이포·상태 통일, 다크모드 대비 확보."

성능 벤치: "Manual: perf-bench. fn() 입력 3종에 대한 CPU/메모리 간단 벤치 및 개선안 제시."

주석

본 Rule은 에이전트의 자율 편차를 최소화하고, 결과물의 테스트 가능성·가독성·유지보수성을 보장하도록 설계됨.

UI 파트는 디자인 토큰과 **접근성 기준(WCAG)**을 내장하여 1차 방어선을 형성.

필요 시 프로젝트별로 색/타이포/스페이싱만 바꿔도 일관된 고품질 UI를 유지.

---
description:
globs:
alwaysApply: false
---
